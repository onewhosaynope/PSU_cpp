/**
 * Пазов В.С.
 * 
 * Экзаменационный билет №10.
 * 
 * Задание 1:
 *   Базовые конструкции структурного программирования. 
 *   Операторы ветвления. 
 * 
 * Задание 2:
 *   Область действия идентификаторов. 
 *   Внешние объявления и поименованные области.
 * 
 * Задание 3: 
 *   Для массива А из N элементов построить гистограмму значений массива:
 *   каждый элемент отображается в одной строке и содержит "*",
 *   равное значению элемента. 
 * 
 * 
 * ========== Ответы задания теории ==========
 * 
 * 
 * Задание 1:
 *   Базовые конструкции структурного программирования. 
 *     Следование, Цикл и Ветвление. 
 *   Операторы ветвления. 
 *     if и switch.
 *     Оператор if разделяет вычисления на два направления. 
 *     Оператор switch способен разделять вычисления на множество направлений.
 * 
 * Задание 2:
 *   Область действия идентификаторов. 
 *     Существуют следующие области: 
 *       блок, файл, функция, объявление функции, класс и пространство имен (namespace).
 *     Блок:
 *       Идентификаторы, описанные внутри блока, являются локальными. 
 *       Область дейтсвия начинается в точке определения и заканчивается в конце блока.
 *       Видимость в пределах блкоа и внутренних блоках. После выхода из блока - память освобождается.
 *     Файл:
 *       Индентификаторы, описанные вне любого блока, фунеции, класса или пространства имен, 
 *       имеют глобальную видимость и могут всегда использоваться с момента их определения.
 *     Функция:
 *       Индентификаторы являются лишь метками. Видимость только внутри функции.
 *       Внутри функции не должно быть совпадений, однако допустимы совпадения с другими функциями.
 *     Объявление функции:
 *       Индентификаторы, указанные в списке параметров объявляемой функции, 
 *       имеют областью только объявление функции.
 *     Класс:
 *       Индентификаторы видны только в пределах класса (если не статик), 
 *       образуются при создании переменной и разрушаются при ее уничтожении.
 *     Пространство имен:
 *       Область действия и видимости совпадают.
 *
 * Внешние объявления и поименованные области. 
 *     Чтобы сделать переменную внешней - используется "extern".
 *     Чтобы ограничить видимость переменной текущим файлом - "static".
 *     Пример внешнего объявления:
 *
 *     *******************
 *     #include <iostream>
 *
 *     extern int global_var(100);  <--- переменная может использоваться в других файлах
 *
 *     int main() {
 *         return 0;
 *     }
 *     *******************
 *
 *     Поименованные области служат для логического группирования объявленийи ограничения доступа к ним.
 *     Объявление имеет формат namespace [ name of namespace ] { variables }
 *     Поименованная область может объявляеться неоднократно, причем последующие объявления
 *     являются расширениями предыдущих.
 */


#include <iostream>
#include <cstdlib>
#include <string>
#include <algorithm>

using namespace std;

void array_fill(int* M, int n);
void array_print(int* M, int n);
void array_random(int* M, int n);
void solution1(int* M, int n);
void solution2(int* M, int n);


int main() {
    int n;
    string option;
    cout << endl << "Array size [N]:" << endl;
    cin >> n;
    int* A = new int[n];
    cout << endl << "Enter \"rand\" to fill array with random values \nor \nenter something else to enter them manually:" << endl;
    cin >> option;
    
    if (option == "rand") {
        array_random(A, n);
    } else {
        array_fill(A, n);
    }
    
    array_print(A, n); 
    solution2(A, n);
    delete[] A;
    return 0;
}


void array_fill(int* M, int n) {
    for(int i = 0; i < n; i++) {
        cout << "M[" << i << "] : ";
            cin >> M[i];
    }
    cout << endl;
}


void array_random(int* M, int n) {
    for(int i = 0; i < n; i++) {
        M[i] = rand() % 100;
    }
}


void array_print(int* M, int n) {
    cout << "Array: ";
    for(int i = 0; i < n; i++) {
        cout << M[i]<< " ";
    }
    cout << endl << endl;
}


void solution1(int* M, int n) {
    string result;
    cout << "Result:" << endl;
    for(int i = 0; i < n; i++) {
        result = result + to_string(M[i]) + " : ";
        for(int j = 0; j < M[i]; j++) {
            result = result + "*";
        }
        result = result + "\n";
    }
    cout << result;
} 


void solution2(int*M, int n) {
    int length = 0;
    int begin = 0;
    int max_length = 0;
    int max_begin = 0;

    for (int i = 1; i < n; i++) {
        if (M[i] < M[i-1]) {
            length++;
        } else {
            if (length > max_length) {
                max_length = length;
                max_begin = begin;
            }
            length = 0;
            begin = i;
        }
    }

    if (max_length > length) {
        length = max_length;
        begin = max_begin;
    }
 
    cout << "Result: ";
    for (int i = begin; i <= begin + length; i++) {
        cout << M[i] << " ";
    }

}
